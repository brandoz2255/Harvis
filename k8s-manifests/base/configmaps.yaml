apiVersion: v1
kind: ConfigMap
metadata:
  name: harvis-ai-backend-config
  namespace: ai-agents
  labels:
    app.kubernetes.io/name: harvis-ai
    app.kubernetes.io/component: backend
data:
  # Backend configuration
  ENVIRONMENT: "production"
  LOG_LEVEL: "INFO"
  CORS_ORIGINS: "*"
  MAX_WORKERS: "4"
  UVICORN_WORKERS: "1"
  # Ollama configuration - using Kubernetes service DNS name
  OLLAMA_CLOUD_URL: "http://harvis-ai-ollama:11434"
---
# Workstation-specific backend config (calls Ollama on Node 1 over network)
apiVersion: v1
kind: ConfigMap
metadata:
  name: harvis-ai-backend-workstation-config
  namespace: ai-agents
  labels:
    app.kubernetes.io/name: harvis-ai
    app.kubernetes.io/component: backend
    app.kubernetes.io/variant: workstation
data:
  # Backend configuration
  ENVIRONMENT: "production"
  LOG_LEVEL: "INFO"
  CORS_ORIGINS: "*"
  MAX_WORKERS: "4"
  UVICORN_WORKERS: "2"
  # Ollama configuration - dedicated Ollama on Node 1 (RTX 4090)
  OLLAMA_URL: "http://harvis-ai-ollama-workstation:11434"
  OLLAMA_CLOUD_URL: "http://harvis-ai-ollama-workstation:11434"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: harvis-ai-frontend-config
  namespace: ai-agents
  labels:
    app.kubernetes.io/name: harvis-ai
    app.kubernetes.io/component: frontend
data:
  # Frontend configuration
  NODE_ENV: "production"
  NEXT_TELEMETRY_DISABLED: "1"
  NEXT_PUBLIC_BACKEND_URL: ""
  # Backend URL for server-side API routes (Next.js API routes calling Python backend)
  BACKEND_URL: "http://harvis-ai-merged-backend:8000"
---
apiVersion: v1
kind: ConfigMap
metadata:
  name: harvis-ai-postgresql-init
  namespace: ai-agents
  labels:
    app.kubernetes.io/name: harvis-ai
    app.kubernetes.io/component: postgresql
data:
  init-db.sh: |
    #!/bin/bash
    set -e

    echo "Starting PostgreSQL database initialization..."
    echo "POSTGRES_USER: $POSTGRES_USER"
    echo "POSTGRES_DB: $POSTGRES_DB"

    # Ensure the main database exists (this should be automatic with POSTGRES_DB env var)
    # But let's verify it exists and create if not
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "postgres" <<-EOSQL
        SELECT 'CREATE DATABASE "'$POSTGRES_DB'"'
        WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = '$POSTGRES_DB')\gexec

        -- Create n8n database for n8n service
        SELECT 'CREATE DATABASE "n8n"'
        WHERE NOT EXISTS (SELECT FROM pg_database WHERE datname = 'n8n')\gexec
    EOSQL

    # Create extensions in the target database
    echo "Creating extensions in database: $POSTGRES_DB"
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
        CREATE EXTENSION IF NOT EXISTS vector;
        CREATE EXTENSION IF NOT EXISTS pg_trgm;
        CREATE EXTENSION IF NOT EXISTS btree_gin;
    EOSQL

    # Create application tables if they don't exist
    echo "Creating application tables..."
    psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
        -- Enable pgcrypto for gen_random_uuid() if not using PG13+
        CREATE EXTENSION IF NOT EXISTS "pgcrypto";

        CREATE TABLE IF NOT EXISTS users (
            id SERIAL PRIMARY KEY,
            username VARCHAR(255) UNIQUE NOT NULL,
            email VARCHAR(255) UNIQUE NOT NULL,
            password VARCHAR(255) NOT NULL,
            avatar VARCHAR(255),
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );

        CREATE TABLE IF NOT EXISTS chat_sessions (
            id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
            user_id INTEGER REFERENCES users(id) ON DELETE CASCADE,
            title VARCHAR(255) NOT NULL DEFAULT 'New Chat',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            last_message_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
            message_count INTEGER DEFAULT 0,
            model_used VARCHAR(100),
            is_active BOOLEAN DEFAULT true
        );

        CREATE TABLE IF NOT EXISTS chat_messages (
            id SERIAL PRIMARY KEY,
            session_id UUID NOT NULL REFERENCES chat_sessions(id) ON DELETE CASCADE,
            user_id INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
            role VARCHAR(20) NOT NULL CHECK (role IN ('user', 'assistant', 'system')),
            content TEXT NOT NULL,
            reasoning TEXT NULL,
            model_used VARCHAR(100),
            input_type VARCHAR(20) DEFAULT 'text' CHECK (input_type IN ('text', 'voice', 'screen')),
            metadata JSONB DEFAULT '{}',
            created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
        );

        -- Add indexes for better performance
        CREATE INDEX IF NOT EXISTS idx_users_email ON users(email);
        CREATE INDEX IF NOT EXISTS idx_users_username ON users(username);
        CREATE INDEX IF NOT EXISTS idx_chat_sessions_user_id ON chat_sessions(user_id);
        CREATE INDEX IF NOT EXISTS idx_chat_sessions_user_updated ON chat_sessions(user_id, updated_at DESC);
        CREATE INDEX IF NOT EXISTS idx_chat_messages_session_id ON chat_messages(session_id);
        CREATE INDEX IF NOT EXISTS idx_chat_messages_session_created ON chat_messages(session_id, created_at ASC);

        -- Trigger function to update session's updated_at and last_message_at
        CREATE OR REPLACE FUNCTION update_session_on_message_insert()
        RETURNS TRIGGER AS \$\$
        BEGIN
            UPDATE chat_sessions 
            SET 
                updated_at = NEW.created_at,
                last_message_at = NEW.created_at,
                message_count = message_count + 1,
                model_used = COALESCE(NEW.model_used, model_used)
            WHERE id = NEW.session_id;
            
            RETURN NEW;
        END;
        \$\$ LANGUAGE plpgsql;

        -- Create trigger if not exists
        DO \$\$
        BEGIN
            IF NOT EXISTS (SELECT 1 FROM pg_trigger WHERE tgname = 'trigger_update_session_on_message_insert') THEN
                CREATE TRIGGER trigger_update_session_on_message_insert
                    AFTER INSERT ON chat_messages
                    FOR EACH ROW
                    EXECUTE FUNCTION update_session_on_message_insert();
            END IF;
        END
        \$\$;
    EOSQL

    echo "âœ… Database initialization completed successfully"
